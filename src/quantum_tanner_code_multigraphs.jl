function _check_allrowscommute(Hx, Hz)
    for rowx in eachrow(Hx)
        for rowz in eachrow(Hz)
            comm = sum(rowx .& rowz)
            isodd(comm) && return false
        end
    end
    return true
end

"""
Construct a generalized Quantum Tanner code.

Returns `(ğ’Ë£, ğ’á¶»)` where `ğ’Ë£` is the X-stabilizer matrix and `ğ’á¶»` is the Z-stabilizer matrix.

### Arguments
- `rate::Real`: Rate parameter for local codes (C_A has rate Ï, C_B has rate 1-Ï)
- `group`: The group G for the left-right Cayley complex
- `A`: Symmetric generating set A for the left Cayley graph
- `B`: Symmetric generating set B for the right Cayley graph  
- `bipartite::Bool`: Whether to use bipartite vertex partitioning (Vâ‚€, Vâ‚)
"""
function gen_code(Ï::Real, group::Group, A::Vector{<:GroupElem}, B::Vector{<:GroupElem}; bipartite=true, use_same_local_code=false)
    @show length(group), length(A), length(B)
    @show length(group)*length(A)*length(B)
    if bipartite
        @assert is_nonconjugate(group, A, B)
        @assert is_symmetric_gen(A)
        @assert is_symmetric_gen(B)
    end
    Î”_A = length(A)
    Î”_B = length(B)
    ğ’¢â‚€â–¡, ğ’¢â‚â–¡, edgeâ‚€_q_idx, edgeâ‚_q_idx, edgeâ‚€_ab_idx, edgeâ‚_ab_idx = bipartite ? cayley_complex_square_graphs(group, A, B) : cayley_complex_square_graphs_quadripartite(group, A, B)
    # "Let C_A, C_B âŠ† ğ”½â‚‚^Î” be classical codes of rates Ï and (1-Ï) respectively" [gu2022efficient](@cite).
    # C_A has rate Ï, C_B has rate 1-Ï. For a code C with rate r = k/n, its dual C^âŠ¥ has rate 1-r.
    # We consider H_A (parity check for C_A) defines C_A^âŠ¥ which has rate 1-Ï.
    # We consider H_B (parity check for C_B) defines C_B^âŠ¥ which has rate Ï.
    rate_H_A = 1-Ï
    rate_H_B = Ï
    Há´¬ = uniformly_random_code_checkmatrix(rate_H_A, Î”_A)
    Há´® = uniformly_random_code_checkmatrix(rate_H_B, Î”_B)
    if use_same_local_code
        Há´® = Há´¬
    end
    # "The dual code of a code C is defined as C^âŠ¥ = {x âˆˆ ğ”½â‚‚â¿: âŸ¨x,yâŸ©=0 âˆ€ y âˆˆ C}" [gu2022efficient](@cite).
    Cá´¬ = dual_code(Há´¬)
    Cá´® = dual_code(Há´®)
    # "An X-type stabilizer generator is defined as a codeword from a generating set of
    # Câ‚€ = C_A âŠ— C_B, with support on the faces incident to a given vertex in Vâ‚€ = Vâ‚€â‚€ âˆª Vâ‚â‚" [gu2022efficient](@cite)
    C_X = kron(Cá´¬, Cá´®)
    # "Similarly, the Z-type stabilizers are generated by codewords of Câ‚ = C_A^âŠ¥ âŠ— C_B^âŠ¥
    # on the faces incident to vertices of Vâ‚ = Vâ‚€â‚ âˆª Vâ‚â‚€" [gu2022efficient](@cite).
    C_Z = kron(Há´¬, Há´®)
    @show size(C_X)
    @show size(C_Z)
    @assert good_css(Há´¬, Cá´¬)
    @assert good_css(Há´®, Cá´®)
    @assert good_css(C_X, C_Z)
    if bipartite
        ğ’Ë£ = tanner_code(ğ’¢â‚€â–¡, edgeâ‚€_q_idx, edgeâ‚€_ab_idx, C_X)  # X-stabilizers from C_A âŠ— C_B on Vâ‚€
        ğ’á¶» = tanner_code(ğ’¢â‚â–¡, edgeâ‚_q_idx, edgeâ‚_ab_idx, C_Z)  # Z-stabilizers from C_A^âŠ¥ âŠ— C_B^âŠ¥ on Vâ‚
    else
        ğ’Ë£ = tanner_code_quadripartite(ğ’¢â‚€â–¡, edgeâ‚€_q_idx, edgeâ‚€_ab_idx, C_X)
        ğ’á¶» = tanner_code_quadripartite(ğ’¢â‚â–¡, edgeâ‚_q_idx, edgeâ‚_ab_idx, C_Z)
    end
    @show r1 = rank(ğ’Ë£)
    @show r2 = rank(ğ’á¶»)
    @assert good_css(ğ’Ë£, ğ’á¶»)
    @assert _check_allrowscommute(ğ’Ë£, ğ’á¶»)
    return ğ’Ë£, ğ’á¶»
end

"""
Generate a good Quantum Tanner code meeting minimum weight requirements.

### Arguments
- `Ï`: Rate parameter for local codes
- `group`, `A`, `B`: Expander graph components  
- `minweight_x`: Minimum weight for X-stabilizers
- `minweight_z`: Minimum weight for Z-stabilizers
- `max_iterations`: Maximum attempts to find a good code
"""
function gen_good_code(Ï::Real, group::Group, A::Vector{<:GroupElem}, B::Vector{<:GroupElem}; minweight_x=1, minweight_z=1, bipartite=true, use_same_local_code=false, max_iterations=100)
    for i in 1:max_iterations
        ğ’Ë£, ğ’á¶» = gen_code(Ï, group, A, B; bipartite, use_same_local_code)
        x_weight = minimum(unique(sum(ğ’Ë£, dims=1)))
        z_weight = minimum(unique(sum(ğ’á¶», dims=1)))
        if x_weight >= minweight_x && z_weight >= minweight_z
            @assert _check_allrowscommute(ğ’Ë£, ğ’á¶»)
            return ğ’Ë£, ğ’á¶»
        end
    end
    throw(ArgumentError("Failed to generate code meeting weight constraints after $max_iterations iterations"))
end
