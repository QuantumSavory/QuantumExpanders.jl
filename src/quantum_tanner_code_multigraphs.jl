function _check_allrowscommute(Hx, Hz)
    for rowx in eachrow(Hx)
        for rowz in eachrow(Hz)
            comm = sum(rowx .& rowz)
            isodd(comm) && return false
        end
    end
    return true
end

"""
Construct a generalized Quantum Tanner code.

Returns `(ğ’Ë£, ğ’á¶»)` where `ğ’Ë£` is the X-stabilizer matrix and `ğ’á¶»` is the Z-stabilizer matrix.

### Arguments
- `rate::Real`: Rate parameter for local codes (C_A has rate Ï, C_B has rate 1-Ï)
- `group`: The group G for the left-right Cayley complex
- `A`: Symmetric generating set A for the left Cayley graph
- `B`: Symmetric generating set B for the right Cayley graph  
- `bipartite::Bool`: Whether to use bipartite vertex partitioning (Vâ‚€, Vâ‚)
"""
struct GeneralizedQuantumTannerCode <: AbstractCSSCode
    """The order of the underlying finite group"""
    group::Group
    """Generating set (closed under inverses) not containing the identity"""
    A::Vector{<:GroupElem}
    """Generating set (closed under inverses) not containing the identity"""
    B::Vector{<:GroupElem}
    """Tuple ((H_A, C_A), (H_B, C_B)) where (H_A, H_B) and (C_A, C_B) are parity-check and generator matrices, respectively."""
    classical_codes::Tuple{Tuple{Matrix{Int}, Matrix{Int}}, Tuple{Matrix{Int}, Matrix{Int}}}
    bipartite::Bool
    use_same_local_code::Bool

    function GeneralizedQuantumTannerCode(group::Group, A::Vector{<:GroupElem}, B::Vector{<:GroupElem},
                                         classical_codes::Tuple{Tuple{Matrix{Int}, Matrix{Int}}, Tuple{Matrix{Int}, Matrix{Int}}};
                                         bipartite=true, use_same_local_code=false)
        if bipartite
            @assert is_nonconjugate(group, A, B)
            @assert is_symmetric_gen(A)
            @assert is_symmetric_gen(B)
        end
        Î”á´¬ = length(A)
        Î”á´® = length(B)
        Há´¬, Cá´¬ = classical_codes[1]
        Há´®, Cá´® = classical_codes[2]
        all(iszero, mod.(Há´¬*transpose(Cá´¬), 2)) || @warn "C_A may not be a valid classical code: Há´¬*Gá´¬^T â‰  0"
        all(iszero, mod.(Há´®*transpose(Cá´®), 2)) || @warn "C_B may not be a valid classical code: Há´®*Gá´®^T â‰  0"
        new(group, A, B, classical_codes, bipartite, use_same_local_code)
    end
end

function parity_matrix_xz(c::GeneralizedQuantumTannerCode)
    group, A, B, classical_codes, bipartite, use_same_local_code = c.group, c.A, c.B, c.classical_codes, c.bipartite, c.use_same_local_code
    Há´¬, Cá´¬ = classical_codes[1]
    Há´®, Cá´® = classical_codes[2]
    if use_same_local_code
        Há´® = Há´¬
    end
    R, _ = residue_ring(ZZ, 2)
    Há´¬, Cá´¬, Há´®, Cá´® = matrix(R, Há´¬), matrix(R, Cá´¬), matrix(R, Há´®), matrix(R, Cá´®)
    # "An X-type stabilizer generator is defined as a codeword from a generating set of
    # Câ‚€ = C_A âŠ— C_B, with support on the faces incident to a given vertex in Vâ‚€ = Vâ‚€â‚€ âˆª Vâ‚â‚" [gu2022efficient](@cite)
    CË£ = kronecker_product(Cá´¬, Cá´®)
    # "Similarly, the Z-type stabilizers are generated by codewords of Câ‚ = C_A^âŠ¥ âŠ— C_B^âŠ¥
    # on the faces incident to vertices of Vâ‚ = Vâ‚€â‚ âˆª Vâ‚â‚€" [gu2022efficient](@cite).
    Cá¶» = kronecker_product(Há´¬, Há´®)
    @show size(CË£)
    @show size(Cá¶»)
    @assert good_css(Há´¬, Cá´¬)
    @assert good_css(Há´®, Cá´®)
    @assert good_css(CË£, Cá¶»)
    ğ’¢â‚€â–¡, ğ’¢â‚â–¡, edgeâ‚€_q_idx, edgeâ‚_q_idx, edgeâ‚€_ab_idx, edgeâ‚_ab_idx = bipartite ? cayley_complex_square_graphs(group, A, B) : cayley_complex_square_graphs_quadripartite(group, A, B)
    if bipartite
        ğ’Ë£ = tanner_code(ğ’¢â‚€â–¡, edgeâ‚€_q_idx, edgeâ‚€_ab_idx, CË£)  # X-stabilizers from C_A âŠ— C_B on Vâ‚€
        ğ’á¶» = tanner_code(ğ’¢â‚â–¡, edgeâ‚_q_idx, edgeâ‚_ab_idx, Cá¶»)  # Z-stabilizers from C_A^âŠ¥ âŠ— C_B^âŠ¥ on Vâ‚
    else
        ğ’Ë£ = tanner_code_quadripartite(ğ’¢â‚€â–¡, edgeâ‚€_q_idx, edgeâ‚€_ab_idx, CË£)
        ğ’á¶» = tanner_code_quadripartite(ğ’¢â‚â–¡, edgeâ‚_q_idx, edgeâ‚_ab_idx, Cá¶»)
    end
    @show r1 = rank(ğ’Ë£)
    @show r2 = rank(ğ’á¶»)
    @assert good_css(ğ’Ë£, ğ’á¶»)
    @assert _check_allrowscommute(ğ’Ë£, ğ’á¶»)
    return ğ’Ë£, ğ’á¶»
end

parity_matrix_x(c::GeneralizedQuantumTannerCode) = parity_matrix_xz(c)[1]

parity_matrix_z(c::GeneralizedQuantumTannerCode) = parity_matrix_xz(c)[2]

function random_quantum_Tanner_code(Ï::Real, group::Group, A::Vector{<:GroupElem}, B::Vector{<:GroupElem}; bipartite=true, use_same_local_code=false)
    @show length(group), length(A), length(B)
    @show length(group)*length(A)*length(B)
    if bipartite
        @assert is_nonconjugate(group, A, B)
        @assert is_symmetric_gen(A)
        @assert is_symmetric_gen(B)
    end
    Î”á´¬ = length(A)
    Î”á´® = length(B)
    ğ’¢â‚€â–¡, ğ’¢â‚â–¡, edgeâ‚€_q_idx, edgeâ‚_q_idx, edgeâ‚€_ab_idx, edgeâ‚_ab_idx = bipartite ? cayley_complex_square_graphs(group, A, B) : cayley_complex_square_graphs_quadripartite(group, A, B)
    # "Let C_A, C_B âŠ† ğ”½â‚‚^Î” be classical codes of rates Ï and (1-Ï) respectively" [gu2022efficient](@cite).
    # C_A has rate Ï, C_B has rate 1-Ï. For a code C with rate r = k/n, its dual C^âŠ¥ has rate 1-r.
    # We consider H_A (parity check for C_A) defines C_A^âŠ¥ which has rate 1-Ï.
    # We consider H_B (parity check for C_B) defines C_B^âŠ¥ which has rate Ï.
    rate_Há´¬ = 1-Ï
    rate_Há´® = Ï
    Há´¬ = uniformly_random_code_checkmatrix(rate_Há´¬, Î”á´¬)
    Há´® = uniformly_random_code_checkmatrix(rate_Há´®, Î”á´®)
    @show Há´¬
    @show Há´®
    if use_same_local_code
        Há´® = Há´¬
    end
    # "The dual code of a code C is defined as C^âŠ¥ = {x âˆˆ ğ”½â‚‚â¿: âŸ¨x,yâŸ©=0 âˆ€ y âˆˆ C}" [gu2022efficient](@cite).
    Cá´¬ = dual_code(Há´¬)
    Cá´® = dual_code(Há´®)
    @show Cá´¬
    @show Cá´®
    # "An X-type stabilizer generator is defined as a codeword from a generating set of
    # Câ‚€ = C_A âŠ— C_B, with support on the faces incident to a given vertex in Vâ‚€ = Vâ‚€â‚€ âˆª Vâ‚â‚" [gu2022efficient](@cite)
    CË£ = kronecker_product(Cá´¬, Cá´®)
    # "Similarly, the Z-type stabilizers are generated by codewords of Câ‚ = C_A^âŠ¥ âŠ— C_B^âŠ¥
    # on the faces incident to vertices of Vâ‚ = Vâ‚€â‚ âˆª Vâ‚â‚€" [gu2022efficient](@cite).
    Cá¶» = kronecker_product(Há´¬, Há´®)
    @show size(CË£)
    @show size(Cá¶»)
    @assert good_css(Há´¬, Cá´¬)
    @assert good_css(Há´®, Cá´®)
    @assert good_css(CË£, Cá¶»)
    if bipartite
        ğ’Ë£ = tanner_code(ğ’¢â‚€â–¡, edgeâ‚€_q_idx, edgeâ‚€_ab_idx, CË£)  # X-stabilizers from C_A âŠ— C_B on Vâ‚€
        ğ’á¶» = tanner_code(ğ’¢â‚â–¡, edgeâ‚_q_idx, edgeâ‚_ab_idx, Cá¶»)  # Z-stabilizers from C_A^âŠ¥ âŠ— C_B^âŠ¥ on Vâ‚
    else
        ğ’Ë£ = tanner_code_quadripartite(ğ’¢â‚€â–¡, edgeâ‚€_q_idx, edgeâ‚€_ab_idx, CË£)
        ğ’á¶» = tanner_code_quadripartite(ğ’¢â‚â–¡, edgeâ‚_q_idx, edgeâ‚_ab_idx, Cá¶»)
    end
    @show r1 = rank(ğ’Ë£)
    @show r2 = rank(ğ’á¶»)
    @assert good_css(ğ’Ë£, ğ’á¶»)
    @assert _check_allrowscommute(ğ’Ë£, ğ’á¶»)
    return ğ’Ë£, ğ’á¶»
end

"""
Generate a good Quantum Tanner code meeting minimum weight requirements.

### Arguments
- `Ï`: Rate parameter for local codes
- `group`, `A`, `B`: Expander graph components  
- `minweight_x`: Minimum weight for X-stabilizers
- `minweight_z`: Minimum weight for Z-stabilizers
- `max_iterations`: Maximum attempts to find a good code
"""
function gen_good_code(Ï::Real, group::Group, A::Vector{<:GroupElem}, B::Vector{<:GroupElem}; minweight_x=1, minweight_z=1, bipartite=true, use_same_local_code=false, max_iterations=100)
    for i in 1:max_iterations
        ğ’Ë£, ğ’á¶» = random_quantum_Tanner_code(Ï, group, A, B; bipartite, use_same_local_code)
        x_weight = minimum(unique(sum(ğ’Ë£, dims=1)))
        z_weight = minimum(unique(sum(ğ’á¶», dims=1)))
        if x_weight >= minweight_x && z_weight >= minweight_z
            @assert _check_allrowscommute(ğ’Ë£, ğ’á¶»)
            return ğ’Ë£, ğ’á¶»
        end
    end
    throw(ArgumentError("Failed to generate code meeting weight constraints after $max_iterations iterations"))
end
