var documenterSearchIndex = {"docs":
[{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#QuantumExpanders.alternative_morgenstern_generators-Tuple{AbstractVector, AllPairs}","page":"API","title":"QuantumExpanders.alternative_morgenstern_generators","text":"Create alternative Morgenstern generators using all pairwise products (i‚â†j).\n\nIntroduced in Sec. 6.1 of (Dinur et al., 2022). Building upon (Morgenstern, 1994).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.alternative_morgenstern_generators-Tuple{AbstractVector, FirstOnly}","page":"API","title":"QuantumExpanders.alternative_morgenstern_generators","text":"Create alternative Morgenstern generators using products with first element only.\n\nIntroduced as the \"better\" alternative in Sec. 6.1 of (Dinur et al., 2022). Building upon (Morgenstern, 1994).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.cayley_complex_square_graphs","page":"API","title":"QuantumExpanders.cayley_complex_square_graphs","text":"Construct the Cayley complex square graphs ùí¢‚ÇÄ‚ñ° and ùí¢‚ÇÅ‚ñ° as presented in (Gu et al., Jun 2022).\n\nIt is more convenient to count the edges as directional (i.e. double counting them), as that makes it much easier to track how edge indices correspond to indices in A√óB.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumExpanders.cayley_complex_square_graphs_quadripartite","page":"API","title":"QuantumExpanders.cayley_complex_square_graphs_quadripartite","text":"Construct the Cayley complex square graphs ùí¢‚ÇÄ‚ñ° and ùí¢‚ÇÅ‚ñ° using the quadripartite construction as presented in (Leverrier and Z√©mor, Apr 2022).\n\nThe quadripartite construction removes the TNC and symmetric generator set conditions.\n\nIt is more convenient to count the edges as directional (i.e. double counting them), as that makes it much easier to track how edge indices correspond to indices in A√óB.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumExpanders.morgenstern_generators-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.morgenstern_generators","text":"Give all Morgenstern generators over PSL‚ÇÇq‚Å±, where i is even, q=2À°, and p is prime.\n\nReturns (SL‚ÇÇq‚Å±, B), where B is the list of generators. As PSL‚ÇÇq‚Å±=SL‚ÇÇq‚Å±, we keep in SL‚ÇÇq‚Å±.\n\nSee (Morgenstern, 1994).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.tanner_code-NTuple{4, Any}","page":"API","title":"QuantumExpanders.tanner_code","text":"Construct the Tanner code for a given multigraph, edge numbering and local code.\n\nThe edge numbering is a map from (vertex, vertex, multiplicity) to index. Most convenient when used with cayley_complex_square_graphs.\n\nAs depicted in (Dinur et al., 2022), (Leverrier and Z√©mor, Apr 2022), and (Gu et al., Jun 2022).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.tanner_code_quadripartite-NTuple{4, Any}","page":"API","title":"QuantumExpanders.tanner_code_quadripartite","text":"Construct the Tanner code for a given multigraph, edge numbering and local code.\n\nThe edge numbering is a map from (vertex, vertex, multiplicity) to index. Most convenient when used with cayley_complex_square_graphs_quadripartite.\n\nAs depicted in (Dinur et al., 2022), (Leverrier and Z√©mor, Apr 2022), and (Gu et al., Jun 2022).\n\n\n\n\n\n","category":"method"},{"location":"API/#Private-API","page":"API","title":"Private API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"danger: Private Implementation Details\nThese functions are used internally by the library and might be drastically modified or deleted without warning or deprecation.","category":"page"},{"location":"API/#Base.kron-Tuple{Nemo.zzModMatrix, Nemo.zzModMatrix}","page":"API","title":"Base.kron","text":"Compute the Kronecker product of binary matrices for constructing tensor product codes in quantum Tanner codes of (Leverrier and Z√©mor, Apr 2022).\n\nWe form tensor product codes from the classical component codes. Specifically, we construct C_0 = C_A otimes C_B and C_1^perp = C_A^perp otimes C_B^perp, which are essential for defining the quantum code through Tanner codes on the left-right Cayley complex.\n\nThe robustness properties of these tensor codes, established in Theorem 9 of (Leverrier and Z√©mor, Apr 2022), are crucial for achieving the linear minimum distance bounds in Theorem 18. This theorem proves that with high probability, the dual tensor code C_A otimes mathbbF_2^B + mathbbF_2^A otimes C_B is Delta^32-varepsilon-robust with Delta^gamma-resistance to puncturing. Both l and r must be matrices of type Nemo.zzModMatrix over the ring GF(2).\n\nExample\n\n```jldoctest julia> using Nemo; R, _ = residue_ring(ZZ, 2);\n\njulia> A = matrix(R, 2, 2, [1, 0, 0, 1])\n\njulia> B = matrix(R, 1, 2, [1, 1]);\n\njulia> kron(A, B) [1   1   0   0] [0   0   1   1]\n\nArguments\n\nl::zzModMatrix: Left matrix in the Kronecker product, typically a generator or parity check matrix of a component code.\nr::zzModMatrix: Right matrix in the Kronecker product, typically a generator or parity check matrix of the other component code.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.cayley_left-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.cayley_left","text":"Construct the CayleyÀ°·µâ·∂†·µó graph for a given group and set of generators.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.cayley_right-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.cayley_right","text":"Construct the Cayley ≥‚Å±·µç ∞·µó graph for a given group and set of generators.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.css-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.css","text":"Create a CSS code from two binary parity check matrices, X and Z\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.dual_code-Tuple{Any}","page":"API","title":"QuantumExpanders.dual_code","text":"Compute the generator matrix of the dual code for classical component codes in quantum Tanner construction (Leverrier and Z√©mor, Apr 2022). We work with pairs of classical codes and their duals to construct quantum CSS codes. The dual code relationship is crucial because quantum Tanner codes are defined through the pair (mathcalC_0 mathcalC_1) where\n\nbeginaligned\nmathcalC_0 = T(mathcalG_0^square C_0^perp) quad C_0 = C_A otimes C_B\nendaligned\n\nand\n\nbeginaligned\nmathcalC_1 = T(mathcalG_1^square C_1^perp) quad C_1 = C_A^perp otimes C_B^perp\nendaligned\n\nTheorem 18 of (Leverrier and Z√©mor, Apr 2022) requires that both the component codes and their duals have sufficiently large minimum distances, which is achieved with high probability when the codes are randomly generated as specified.\n\nExample\n\njulia> using QuantumExpanders: dual_code # hide\n\njulia> H = uniformly_random_code_checkmatrix(0.5, 10);\n\njulia> G = dual_code(H)\n[0   1   1   1   1   1   0   0   0   0]\n[0   1   1   0   1   0   1   0   0   0]\n[0   0   1   1   1   0   0   1   0   0]\n[1   0   1   1   0   0   0   0   1   0]\n[0   0   0   0   1   0   0   0   0   1]\n\njulia> G * transpose(H) == zero_matrix(base_ring(G), size(G, 1), size(H, 1))\ntrue\n\nArguments\n\nH::zzModMatrix: Parity check matrix of a classical linear code, typically one of the component codes C_A or C_B.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.good_css-Tuple{Union{Nemo.zzModMatrix, AbstractMatrix{Bool}}, Union{Nemo.zzModMatrix, AbstractMatrix{Bool}}}","page":"API","title":"QuantumExpanders.good_css","text":"Check that two binary parity check matrices X and Z result in a good CSS code (i.e., commutation constraints are fulfilled)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.is_nonconjugate-Tuple{Any, Any, Any}","page":"API","title":"QuantumExpanders.is_nonconjugate","text":"Check the TNC condition of (Dinur et al., 2022).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.is_symmetric_gen-Tuple{Any}","page":"API","title":"QuantumExpanders.is_symmetric_gen","text":"Check the generating set is symmetric.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.morgenstern_f-Tuple{Any}","page":"API","title":"QuantumExpanders.morgenstern_f","text":"Randomly sample for Œµ‚ààùîΩq until you find one such that x^2+x+Œµ‚ààùîΩq[x] is irreducible.\n\nTakes as input ùîΩq[x], the polynomial ring we want to work with.\n\nReturns x^2+x+Œµ.\n\nSee (Morgenstern, 1994).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.morgenstern_solutions-Tuple{Any}","page":"API","title":"QuantumExpanders.morgenstern_solutions","text":"Internally call the morgenstern_f sampler to find an irreducible x^2+x+Œµ‚ààùîΩq[x]. Then find all q+1 solutions (Œ≥,Œ¥) of Œ≥¬≤+Œ≥Œ¥+Œ¥¬≤Œµ=1.\n\nTakes as input ùîΩq[x], the polynomial ring we want to work with.\n\nReturns (Œµ, sols), where sols is the list of solutions.\n\nSee (Morgenstern, 1994).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.uniformly_random_code_checkmatrix-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.uniformly_random_code_checkmatrix","text":"Generate a random binary parity check matrix for classical component codes used in quantum Tanner code construction (Leverrier and Z√©mor, Apr 2022).\n\nLocal Component Codes\n\nThe random classical code generation is essential for building quantum Tanner codes as described in (Leverrier and Z√©mor, Apr 2022). Theorem 18 of (Leverrier and Z√©mor, Apr 2022) establishes that for sufficiently large Delta, random codes with specific rates yield asymptotically good quantum Tanner codes with high probability. Specifically, this theorem requires choosing C_A via a random uniform r times Delta generator matrix and C_B via a random uniform r times Delta parity-check matrix, wherer = lfloor rho Delta rfloor.\n\nnote: Note\nThe parameters must satisfy -delta log_2 delta - (1-delta) log_2 (1-delta)  rho (Gilbert-Varshamov bound). This condition ensures that random codes of rate rho can achieve relative minimum distance delta, which is necessary for all four codes C_A, C_B, C_A^perp, C_B^perp to have minimum distances geq deltaDelta with high probability. The parameter rho must satisfy 0  rho  12 to ensure non-trivial quantum codes.\n\nThe randomness is fundamental to obtaining codes with the robustness properties established in Theorem 9 of (Leverrier and Z√©mor, Apr 2022), which guarantees that with probability tending to 1 as Delta to infty, the dual tensor code\n\nbeginaligned\nC_A otimes mathbbF_2^B + mathbbF_2^A otimes C_B\nendaligned\n\nis Delta^32-varepsilon-robust with Delta^gamma-resistance to puncturing.\n\nExample\n\njulia> using QuantumExpanders: uniformly_random_code_checkmatrix;\n\njulia> H = uniformly_random_code_checkmatrix(0.5, 10)\n[0   0   1   1   0   0   1   1   0   1]\n[1   1   0   0   1   0   0   0   1   0]\n[1   1   1   0   0   0   0   1   1   1]\n[1   1   1   0   0   1   0   1   1   1]\n[0   0   0   1   1   1   0   0   1   0]\n\nArguments\n\nœÅ::Real: Target rate of the classical component code, determining the code's dimension relative to its block length.\nŒî::Integer: Block length of the classical component code, corresponding to the size of the generating sets in the underlying Cayley graph structure.\n\n\n\n\n\n","category":"method"}]
}
