var documenterSearchIndex = {"docs":
[{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#QuantumExpanders.alternative_morgenstern_generators-Tuple{AbstractVector, AllPairs}","page":"API","title":"QuantumExpanders.alternative_morgenstern_generators","text":"Create alternative Morgenstern generators using all pairwise products (i‚â†j).\n\nMorgenstern showed that for every prime q, there exist infinitely many groups G_i = mathrmPGL_2(q^i) or G_i = mathrmPSL_2(q^i), each with a symmetric generating set B_i of size q+1, such that the Cayley graphs mathrmCay(G_i B_i) are Ramanujan graphs ((Morgenstern, 1994), (Dinur et al., 2022)). That is, the second largest eigenvalue satisfies lambda(mathrmCay(G_i B_i)) leq 2sqrtq(q+1).\n\nThe construction uses an explicit arithmetic lattice Gamma in mathrmPSL_2(mathbbF_q) that is isomorphic to the free product of q+1 copies of the cyclic group of order 2, where B = b_0 b_1 ldots b_q consists of elements of order 2 (Dinur et al., 2022). The Cayley graphs are obtained as images B_i = phi(B) under epimorphisms phi Gamma to G_i.\n\nDinur provided an alternative construction of symmetric generating sets A_i for G_i = mathrmPGL_2(q^i) such that the pairs (A_i B_i) satisfy the total non-congruency condition (Dinur et al., 2022) for Morgenstern construction of Ramanujan graphs using even prime q.\n\nGenerator Constructions\n\nAll Pairs Construction\n\nThe subgroup Lambda is generated by the symmetric set\n\nbeginaligned\nA = b_t b_s mid b_t b_s in B t neq s\nendaligned\n\nwhich has size k_1 = q^2 + q. For a finite group G with symmetric generating set B where each element has order 2, the all pairs construction generates the alternative generating set:\n\nbeginaligned\nA = b_i b_j mid b_i b_j in B i neq j\nendaligned\n\nThis construction yields Cayley graphs textCay(G_i A_i) with spectral expansion satisfying:\n\nbeginaligned\nlambda(textCay(G_i A_i))  frac3q-1q^2+q  frac3sqrtk_1-1k_1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.alternative_morgenstern_generators-Tuple{AbstractVector, FirstOnly}","page":"API","title":"QuantumExpanders.alternative_morgenstern_generators","text":"Create alternative Morgenstern generators using products with first element only.\n\nGenerator Constructions\n\nFirst Element Construction\n\nA more efficient construction recognizes that Lambda is actually a free group on the q generators b_0 b_j  j = 1 ldots q. Since (b_0 b_j)^-1 = b_j b_0, we obtain the symmetric generating set:\n\nbeginaligned\nA = b_0 b_j b_j b_0 mid j = 1 ldots q\nendaligned\n\nThis construction produces Cayley graphs with improved spectral properties:\n\nbeginaligned\nlambda(textCay(G_i A_i))  frac3sqrt2q-12q\nendaligned\n\nThe default constructor uses the more efficient FirstOnly algorithm, providing better spectral expansion with smaller generating sets of size k_1 = 2q compared to k_1 = q^2 + q for the all pairs construction.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.cayley_complex_square_graphs","page":"API","title":"QuantumExpanders.cayley_complex_square_graphs","text":"Construct the Cayley complex square graphs ùí¢‚ÇÄ‚ñ° and ùí¢‚ÇÅ‚ñ° as presented in (Gu et al., Jun 2022).\n\nIt is more convenient to count the edges as directional (i.e. double counting them), as that makes it much easier to track how edge indices correspond to indices in A√óB.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumExpanders.cayley_complex_square_graphs_quadripartite","page":"API","title":"QuantumExpanders.cayley_complex_square_graphs_quadripartite","text":"Construct the Cayley complex square graphs ùí¢‚ÇÄ‚ñ° and ùí¢‚ÇÅ‚ñ° using the quadripartite construction as presented in (Leverrier and Z√©mor, Apr 2022).\n\nThe quadripartite construction removes the TNC and symmetric generator set conditions.\n\nIt is more convenient to count the edges as directional (i.e. double counting them), as that makes it much easier to track how edge indices correspond to indices in A√óB.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumExpanders.morgenstern_generators-Tuple{Int64, Int64}","page":"API","title":"QuantumExpanders.morgenstern_generators","text":"Give all Morgenstern generators over PSL_2(q^i), where i is even, q=2^l, and p is prime.\n\nThe theorem 5.13 of (Morgenstern, 1994) provides a method to construct families of (q+1)-regular Ramanujan graphs for even prime powers q. This explicit construction produces Cayley graphs of the projective special linear group mathrmPSL_2(mathbbF_q^d) with respect to a specific set of q+1 generators. These generators are 2 times 2 matrices of the form:\n\nbeginaligned\nbeginpmatrix\n1  gamma_k + delta_kmathbbi \n(gamma_k + delta_kmathbbi + delta_k)x  1\nendpmatrix quad k=1ldotsq+1\nendaligned\n\nwhere q = 2^l is an even prime power, and d is an even integer extension degree. The field mathbbF_q^d is constructed as mathbbF_qxg(x)mathbbF_qx where g(x) is an irreducible polynomial of degree d. Within this field, mathbbi denotes a root of the irreducible polynomial x^2 + x + varepsilon = 0. The pairs (gamma_k delta_k) are the q+1 solutions in \\mathbb{F}_q^2to the\\gamma_k^2 + \\gamma_k\\delta_k + \\delta_k^2\\varepsilon = 1. And x is the polynomial variable that represents an element of\\mathbb{F}_{q^d}` in the construction.\n\nThe same theorem states that the resulting Cayley graph Gamma_g has the following properties: it is a (q+1)-regular Ramanujan graph of order Gamma_g = q^3d - q^d and is non-bipartite. The graph has girth at least frac23log_qGamma_g and diameter at most 2log_qGamma_g + 2. Furthermore, as per Theorem 5.11, all eigenvalues mu of the adjacency matrix satisfy mu leq 2sqrtq for mu neq\\pm(q+1)``.\n\nnote: Note\nIn the construction of Morgenstern Ramanujan graphs for even prime powers q = 2^l, we utilize the fact that in characteristic 2, the projective special linear group mathrmPSL_2(mathbbF_q) is isomorphic to the special linear group mathrmSL_2(mathbbF_q). This isomorphism holds because the center of mathrmSL_2(mathbbF_q) is trivial in characteristic 2 when q is even as confirmed by identity Z cap SL(2 mathbbF) = I. \n\nReturns (SL_2(q^i) B), where B is the list of generators. As PSL_2(q^i) = SL_2(q^i), we work in SL_2(q^i).\n\nArguments\n\nl: A positive integer specifying that q = 2^l, where q is the size of the base field mathbbF_q.\ni: An even positive integer specifying the extension degree for the field mathbbF_q^i. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.tanner_code-NTuple{4, Any}","page":"API","title":"QuantumExpanders.tanner_code","text":"Construct the Tanner code for a given multigraph, edge numbering and local code.\n\nThe edge numbering is a map from (vertex, vertex, multiplicity) to index. Most convenient when used with cayley_complex_square_graphs.\n\nAs depicted in (Dinur et al., 2022), (Leverrier and Z√©mor, Apr 2022), and (Gu et al., Jun 2022).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.tanner_code_quadripartite-NTuple{4, Any}","page":"API","title":"QuantumExpanders.tanner_code_quadripartite","text":"Construct the Tanner code for a given multigraph, edge numbering and local code.\n\nThe edge numbering is a map from (vertex, vertex, multiplicity) to index. Most convenient when used with cayley_complex_square_graphs_quadripartite.\n\nAs depicted in (Dinur et al., 2022), (Leverrier and Z√©mor, Apr 2022), and (Gu et al., Jun 2022).\n\n\n\n\n\n","category":"method"},{"location":"API/#Private-API","page":"API","title":"Private API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"danger: Private Implementation Details\nThese functions are used internally by the library and might be drastically modified or deleted without warning or deprecation.","category":"page"},{"location":"API/#Base.kron-Tuple{Nemo.zzModMatrix, Nemo.zzModMatrix}","page":"API","title":"Base.kron","text":"Compute the Kronecker product of binary matrices for constructing tensor product codes in quantum Tanner codes of (Leverrier and Z√©mor, Apr 2022).\n\nWe form tensor product codes from the classical component codes. Specifically, we construct C_0 = C_A otimes C_B and C_1^perp = C_A^perp otimes C_B^perp, which are essential for defining the quantum code through Tanner codes on the left-right Cayley complex.\n\nThe robustness properties of these tensor codes, established in Theorem 9 of (Leverrier and Z√©mor, Apr 2022), are crucial for achieving the linear minimum distance bounds in Theorem 18. This theorem proves that with high probability, the dual tensor code C_A otimes mathbbF_2^B + mathbbF_2^A otimes C_B is Delta^32-varepsilon-robust with Delta^gamma-resistance to puncturing. Both l and r must be matrices of type Nemo.zzModMatrix over the ring GF(2).\n\nExample\n\n```jldoctest julia> using Nemo; R, _ = residue_ring(ZZ, 2);\n\njulia> A = matrix(R, 2, 2, [1, 0, 0, 1])\n\njulia> B = matrix(R, 1, 2, [1, 1]);\n\njulia> kron(A, B) [1   1   0   0] [0   0   1   1]\n\nArguments\n\nl::zzModMatrix: Left matrix in the Kronecker product, typically a generator or parity check matrix of a component code.\nr::zzModMatrix: Right matrix in the Kronecker product, typically a generator or parity check matrix of the other component code.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.cayley_left-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.cayley_left","text":"Construct the CayleyÀ°·µâ·∂†·µó graph for a given group and set of generators.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.cayley_right-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.cayley_right","text":"Construct the Cayley ≥‚Å±·µç ∞·µó graph for a given group and set of generators.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.css-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.css","text":"Create a CSS code from two binary parity check matrices, X and Z\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.dual_code-Tuple{Any}","page":"API","title":"QuantumExpanders.dual_code","text":"Compute the generator matrix of the dual code for classical component codes in quantum Tanner construction (Leverrier and Z√©mor, Apr 2022). We work with pairs of classical codes and their duals to construct quantum CSS codes. The dual code relationship is crucial because quantum Tanner codes are defined through the pair (mathcalC_0 mathcalC_1) where\n\nbeginaligned\nmathcalC_0 = T(mathcalG_0^square C_0^perp) quad C_0 = C_A otimes C_B\nendaligned\n\nand\n\nbeginaligned\nmathcalC_1 = T(mathcalG_1^square C_1^perp) quad C_1 = C_A^perp otimes C_B^perp\nendaligned\n\nTheorem 18 of (Leverrier and Z√©mor, Apr 2022) requires that both the component codes and their duals have sufficiently large minimum distances, which is achieved with high probability when the codes are randomly generated as specified.\n\nExample\n\njulia> using QuantumExpanders: dual_code # hide\n\njulia> H = uniformly_random_code_checkmatrix(0.5, 10);\n\njulia> G = dual_code(H)\n[0   1   1   1   1   1   0   0   0   0]\n[0   1   1   0   1   0   1   0   0   0]\n[0   0   1   1   1   0   0   1   0   0]\n[1   0   1   1   0   0   0   0   1   0]\n[0   0   0   0   1   0   0   0   0   1]\n\njulia> G * transpose(H) == zero_matrix(base_ring(G), size(G, 1), size(H, 1))\ntrue\n\nArguments\n\nH::zzModMatrix: Parity check matrix of a classical linear code, typically one of the component codes C_A or C_B.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.good_css-Tuple{Union{Nemo.zzModMatrix, AbstractMatrix{Bool}}, Union{Nemo.zzModMatrix, AbstractMatrix{Bool}}}","page":"API","title":"QuantumExpanders.good_css","text":"Check that two binary parity check matrices X and Z result in a good CSS code (i.e., commutation constraints are fulfilled)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.is_nonconjugate-Tuple{Any, Any, Any}","page":"API","title":"QuantumExpanders.is_nonconjugate","text":"Check the TNC condition of (Dinur et al., 2022).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.is_symmetric_gen-Tuple{Any}","page":"API","title":"QuantumExpanders.is_symmetric_gen","text":"Check the generating set is symmetric.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.morgenstern_f-Tuple{Nemo.FqPolyRing}","page":"API","title":"QuantumExpanders.morgenstern_f","text":"Finds an irreducible polynomial of the form f(x) = x^2 + x + varepsilon over the finite field mathbbF_q.\n\nSeparability\n\nIn characteristic 2, the quadratic form x^2 + varepsilon has derivative zero. A polynomial is separable if and only if it is relatively prime to its derivative (Dummit et al., 2004). When (f f) neq 1, the polynomial is inseparable.\n\nWhen such polynomials are reducible, they have repeated roots:\n\njulia> using Oscar\n\njulia> ùîΩ‚ÇÇ, _ = finite_field(2, 1, \"a\");\n\njulia> R, x = polynomial_ring(ùîΩ‚ÇÇ, \"x\");\n\njulia> f = x^2 + ùîΩ‚ÇÇ(1);\n\njulia> derivative(f) == 0\ntrue\n\njulia> gcd(f, derivative(f)) == 1\nfalse\n\njulia> ùîΩ‚ÇÑ, _ = finite_field(2, 2, \"b\");\n\njulia> R‚ÇÑ, y = polynomial_ring(ùîΩ‚ÇÑ, \"y\");\n\njulia> factor(y^2 + ùîΩ‚ÇÑ(1))\n1 * (y + 1)^2\n\nThe form x^2 + x + varepsilon is used instead because its derivative is 1 (nonzero), ensuring that all roots are distinct.\n\njulia> using Oscar\n\njulia> ùîΩ‚ÇÇ, _ = finite_field(2, 1, :a);\n\njulia> R, x = polynomial_ring(ùîΩ‚ÇÇ, :x);\n\njulia> f = x^2 + x + ùîΩ‚ÇÇ(1);\n\njulia> is_irreducible(f) && is_separable(f) && derivative(f) == 1\ntrue\n\njulia> gcd(f, derivative(f)) == 1\ntrue\n\njulia> g = x^2 + x + ùîΩ‚ÇÇ(0);\n\njulia> roots(g)\n2-element Vector{FqFieldElem}:\n 0\n 1\n\nMorgenstern's construction of Ramanujan graphs for even prime power q\n\nThe construction requires a quaternion algebra over mathbbF_q(x) of the form (Morgenstern, 1994):\n\nbeginaligned\nmathcalA = kmathbf1 + kmathbfi + kmathbfj + kmathbfij quad\nmathbfi^2 = mathbfi + varepsilon quad mathbfj^2 = x quad mathbfij = mathbfji + mathbfj\nendaligned\n\nwhere k = mathbbF_q(x) and f(x) = x^2 + x + varepsilon is irreducible over mathbbF_q.\n\nThe norm in this algebra is given by:\n\nbeginaligned\nN(a + bmathbfi + cmathbfj + dmathbfij) = a^2 + b^2varepsilon + ab + (c^2 + d^2varepsilon + cd)x\nendaligned\n\nThe \"basic norm\" elements that generate the Ramanujan graphs are exactly those of the form (Morgenstern, 1994):\n\nbeginaligned\nxi = 1 + gammamathbfj + deltamathbfij quad textwhere  gamma delta in mathbbF_q\nendaligned\n\nsatisfy\n\nbeginaligned\ngamma^2 + gammadelta + delta^2varepsilon = 1\nendaligned\n\nThis equation has exactly q+1 solutions in mathbbF_q, providing the q+1 generators needed  for (q+1)-regular Ramanujan graphs.\n\nUnder the isomorphism theta mathcalA to M_2(k), these generators map to matrices (Morgenstern, 1994):\n\nbeginpmatrix\n1  gamma + delta i \n(gamma + delta i + delta)x  1\nendpmatrix\n\nwhere i is a root of x^2 + x + varepsilon = 0.\n\nThe selection of an irreducible polynomial of the form x^2 + x + varepsilon is essential for defining the quaternion algebra mathcalA. This algebra is constructed to be ramified at the place 1x (the infinite place) and split at a finite place p (where p neq 1x). The irreducibility of f(x) over mathbbF_q ensures that the algebra is a skewfield at the infinite place, a necessary condition for the construction of a co-compact lattice Gamma(g) (see Lemma 3.1 of (Morgenstern, 1994)) via the strong approximation theorem.\n\nArguments\n\nR: Polynomial ring mathbbF_qx used to construct the irreducible polynomial for Morgenstern's quaternion algebra.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.morgenstern_solutions-Tuple{Nemo.FqPolyRing}","page":"API","title":"QuantumExpanders.morgenstern_solutions","text":"Internally call the morgenstern_f sampler to find an irreducible x^2 + x + varepsilon in mathbbF_qx.\n\nFind all q + 1 solutions (gamma delta) in mathbbF_q^2 to the gamma^2 + gammadelta + delta^2varepsilon = 1.\n\nQuaternion Algebra\n\nA quaternion algebra over k = mathbbF_q(x) is a skewfield mathcalA with center k that has degree four as a vector space over k. In Morgenstern's explicit construction of Ramanujan graphs for even prime power q (Morgenstern, 1994), a specific quaternion algebra is defined as\n\nbeginaligned\nmathscrA = kmathbf1 + kmathbfi + kmathbfj + kmathbfij\nendaligned\n\nwith relations\n\nbeginaligned\nmathbfi^2 = mathbfi + varepsilon mathbfj^2 = x mathbfij = mathbfji + mathbfj\nendaligned\n\nThe parameter varepsilon in mathbbF_q is chosen so that the polynomial f(x) = x^2 + x + varepsilon is irreducible over mathbbF_q. This ensures mathcalA is a skewfield. The algebra is ramified at the finite place x and at 1x.\n\nThe connection to graph theory arises from studying elements in the integral set\n\nbeginaligned\nmathscrS = mathbbF_qxmathbf1 + mathbbF_qxmathbfi + mathbbF_qxmathbfj + mathbbF_qxmathbfij\nendaligned\n\nThe \"basic norm x+1\" elements are defined as\n\nbeginaligned\nxi = 1 + gammamathbfj + deltamathbfij quad textwith gamma delta in mathbbF_q\nendaligned\n\nsatisfying the norm equation N(xi) = gamma^2 + gammadelta + delta^2\u000barepsilon = 1. This equation has exactly q+1 solutions in mathbbF_q, parameterizing generators xi_1 dots xi_q+1. These generators define a free product group \n\nbeginaligned\nA(x) = langle xi_1 rangle * langle xi_2 rangle * cdots * langle xi_q+1 rangle\nendaligned\n\nwhich acts simply transitively on the q+1-regular tree T_x+1 = G_x+1G_O_x+1. Taking the quotient by a congruence subgroup A(g), where g(x) is irreducible of even degree, yields a finite (q+1)-regular graph Gamma_g = A(g) backslash T_x+1. This graph is the Cayley graph of PSL_2(mathbbF_q^d) with respect to the images of the q+1 generators.\n\nArguments\n\nR: Polynomial ring mathbbF_qx where q is a power of 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumExpanders.uniformly_random_code_checkmatrix-Tuple{Any, Any}","page":"API","title":"QuantumExpanders.uniformly_random_code_checkmatrix","text":"Generate a random binary parity check matrix for classical component codes used in quantum Tanner code construction (Leverrier and Z√©mor, Apr 2022).\n\nLocal Component Codes\n\nThe random classical code generation is essential for building quantum Tanner codes as described in (Leverrier and Z√©mor, Apr 2022). Theorem 18 of (Leverrier and Z√©mor, Apr 2022) establishes that for sufficiently large Delta, random codes with specific rates yield asymptotically good quantum Tanner codes with high probability. Specifically, this theorem requires choosing C_A via a random uniform r times Delta generator matrix and C_B via a random uniform r times Delta parity-check matrix, wherer = lfloor rho Delta rfloor.\n\nnote: Note\nThe parameters must satisfy -delta log_2 delta - (1-delta) log_2 (1-delta)  rho (Gilbert-Varshamov bound). This condition ensures that random codes of rate rho can achieve relative minimum distance delta, which is necessary for all four codes C_A, C_B, C_A^perp, C_B^perp to have minimum distances geq deltaDelta with high probability. The parameter rho must satisfy 0  rho  12 to ensure non-trivial quantum codes.\n\nThe randomness is fundamental to obtaining codes with the robustness properties established in Theorem 9 of (Leverrier and Z√©mor, Apr 2022), which guarantees that with probability tending to 1 as Delta to infty, the dual tensor code\n\nbeginaligned\nC_A otimes mathbbF_2^B + mathbbF_2^A otimes C_B\nendaligned\n\nis Delta^32-varepsilon-robust with Delta^gamma-resistance to puncturing.\n\nExample\n\njulia> using QuantumExpanders: uniformly_random_code_checkmatrix;\n\njulia> H = uniformly_random_code_checkmatrix(0.5, 10)\n[0   0   1   1   0   0   1   1   0   1]\n[1   1   0   0   1   0   0   0   1   0]\n[1   1   1   0   0   0   0   1   1   1]\n[1   1   1   0   0   1   0   1   1   1]\n[0   0   0   1   1   1   0   0   1   0]\n\nArguments\n\nœÅ::Real: Target rate of the classical component code, determining the code's dimension relative to its block length.\nŒî::Integer: Block length of the classical component code, corresponding to the size of the generating sets in the underlying Cayley graph structure.\n\n\n\n\n\n","category":"method"}]
}
